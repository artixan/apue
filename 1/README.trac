= 1 概論 =

1.1, 1.2 は飛ばします。

== 1.3 ファイルとディレクトリ ==

 * ファイル名に使えない文字はスラッシュ(/)とnull文字のみ
 * ls(1) を見るには man 1 ls する

ところで man(1) で見れるセクション(ここでは1とか)については次のような取り決めがある。

 Section 1::
   コマンドアプリケーションの説明
 Section 2::
   システムコールの説明
 Section 3::
   ライブラリルーチンの説明
 Section 4::
   デバイスドライバの説明
 Section 5::
   ファイルに対する説明
 Section 6:: 
   ゲームに対する説明
 Section 7::
   共有ファイル(share)に関する説明
 Section 8::
   システム管理に関する説明

この輪講を通じてお世話になるセクションのほどんどは2, 3だと思われる。

コードに移る前に、[http://www.apuebook.com/index.html Advanced Programming in the UNIX® Environment, Second Edition] にある Source Code の配置を参考にしつつ、自分は以下のようなディレクトリ構成で進める事にした。

{{{
$ tree
.
├── 1
│   ├── Makefile
│   ├── README.trac
│   └── myls.c
├── include
│   └── error.h
└── lib
    └── error.c
}}}

[https://github.com/zigorou/apue/blob/master/lib/error.c error.c], [https://github.com/zigorou/apue/blob/master/lib/error.h error.h] では頻出するエラー発生時のメッセージ表示及び exit(3) を行う関数群が入っている。これは UNIX Network Programming より拝借して適当に書き直したものである。

ここで「プログラム1.1 ディレクトリ内のすべてのファイルをリストする」を [https://github.com/zigorou/apue/blob/master/1/myls.c 1/myls.c] として示す。

{{{
#!c
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <dirent.h>

#include "error.h"

int main(int argc, char **argv) {
    DIR *dp;
    struct dirent *dirp;
    
    if (argc != 2)
        err_quit("a single argument (the directory name) is required");

    if ( ( dp = opendir(argv[1]) ) == NULL )
        err_sys("can't open %s", argv[1]);

    while (( dirp = readdir(dp) ) != NULL)
        printf("%s\n", dirp->d_name);

    closedir(dp);

    exit(0);
}
}}}

少し脱線すると、利用する標準関数として opendir(3), readdir(3), closedir(3) があり、これらを man 3 opendir 等すると dirent.h を include しなければならないのは容易に分かる。
その他に exit(3) を使うので stdlib.h を include し、さらに NULL は stddef.h で定義されている。

ディレクトリ内部を列挙するに辺り行う操作の手順は、

 1. opendir(3) で DIR ポインタを生成
 2. readdir(3) で DIR ポインタを元に NULL が返るまで dirent 構造体ポインタを取得する
 3. dirent 構造体ポインタを参照
 4. closedir(3) によって DIR ポインタを閉じる

という一連の操作になる。

{{{
#!c
DIR * opendir(const char *dirname);
struct dirent *readdir(DIR *dirp);
int closedir(DIR *dirp);
}}}

man 3 opendir より、

  The opendir() function opens the directory named by dirname, associates a directory stream with it, 
  and returns a pointer to be used to identify the directory stream in subsequent operations. 
  The pointer NULL is returned if dirname cannot be accessed or if it cannot malloc(3) enough memory to hold the whole thing.

とあるように、opendir(3) は dirname にアクセス出来なかったり十分なメモリが確保できない際に NULL ポインタを返す。一方で readdir(3) は、

  The readdir() function returns a pointer to the next directory entry. 
  It returns NULL upon reaching the end of the directory or detecting an invalid seekdir() operation.

とあるので、NULL ポインタが返ってくるまで dirent 構造体のポインタが返ってくる事が分かる。

== 1.4 入力と出力 ==

 ファイル記述子 (file descriptor)::
   プロセスが参照するファイル等を識別するためにカーネルが使用する非負の整数。カーネルがファイルを開いたり作ったりする度に、ファイル記述子を返す。
 アンバッファド入出力::
   open(2), read(2), write(2), lseek(2), close(2) といったシステムコールは、バッファリングしない入出力機能を提供する。これらの関数はファイル記述子を通して用いられる。

次に「プログラム1.2 標準入力から標準出力へのコピー」を [https://github.com/zigorou/apue/blob/master/1/mycat.c 1/mycat.c] として以下に示す。

{{{
#!c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>

#include "error.h"

#define BUFFSIZE 8192

int main(int argc, char **argv) {
    int n;
    char buf[BUFFSIZE];

    while ( ( n = read(STDIN_FILENO, buf, BUFFSIZE) ) > 0 ) {
        if (write(STDOUT_FILENO, buf, n) != n)
            err_sys("write error");
    }
    
    if ( n < 0 )
        err_sys("read error");

    exit(0);
}
}}}

STDIN_FILENO, STDOUT_FILENO は unistd.h で定義されている。read(2), write(2) に伴うヘッダファイルの include は man を参照の事。

{{{
#!c
ssize_t read(int fildes, void *buf, size_t nbyte);
ssize_t write(int fildes, const void *buf, size_t nbyte);
}}}

man 2 read すると、

    RETURN VALUES
         If successful, the number of bytes actually read is returned.
         Upon reading end-of-file, zero is returned.
         Otherwise, a -1 is returned and the global variable errno is set to indicate the error.

とある。つまり、通常は読み込めたバイト数を返す。0 が返ってきた場合は EOF であり、-1 が返ってきた場合は何らかのエラーが返ってきており、詳細は errno というグローバル変数にエラーコードが設定されている。詳細なエラーは man に書いてある。

次に man 2 write する。

    RETURN VALUES
         Upon successful completion the number of bytes which were written is returned.
         Otherwise, a -1 is returned and the global variable errno is set to indicate the error.

書き込めたバイト数が通常は返され、-1 が返ってきたときはエラーであるという点は read(2) と同じインターフェースである。

 標準入出力関数::
   read(2), write(2) のようなアンバッファド入出力関数ではなく、バッファリングする関数の事。stdio.h で提供されている。
   fgets(3), getc(3), putc(3) のような関数がそれに該当する。

次に「プログラム1.3 標準入出力関数を用いた標準入力から標準出力へのコピー」を [https://github.com/zigorou/apue/blob/master/1/getcputc.c 1/getcputc.c] に示す。

{{{
#!c
#include <stdio.h>
#include <stdlib.h>

#include "error.h"

int main(int argc, char **argv) {
    int c;

    while ( ( c = getc(stdin) ) != EOF ) {
        if ( putc(c, stdout) == EOF )
            err_sys("output error");
    }

    if (ferror(stdin))
        err_sys("input error");

    exit(0);
}
}}}

{{{
#!c
int getc(FILE *stream);
int putc(int c, FILE *stream);
int ferror(FILE *stream);
}}}

まずは man 3 getc より、

    RETURN VALUES
        If successful, these routines return the next requested object from the stream. 
        Character values are returned as an unsigned char converted to an int.
        If the stream is at end-of-file or a read error occurs, the routines return EOF. 
        The routines feof(3) and ferror(3) must be used to distinguish between end-of-file and error. 
        If an error occurs, the global variable errno is set to indicate the error. 
        The end-of-file condition is remembered, even on a terminal, 
        and all subsequent attempts to read will return EOF until the condition is cleared with clearerr(3).

通常は読み込んだ 1 byte の unsigned char を int にコンバートした物が返される。ファイルの終端またはエラーが発生した場合は EOF が返される。
(つまり EOF は本当の意味での EOF ではなく、エラーが発生している場合もある)
従って、このサンプルコードにあるように getc(3) で EOF が発生した後に ferror(3) により検査する必要がある。

次に man 3 putc を見る。

    RETURN VALUES
         The functions, fputc(), putc(), putchar(), putc_unlocked(), and putchar_unlocked() return the character written.
         If an error occurs, the value EOF is returned.
         The putw() function returns 0 on success; EOF is returned if a write error occurs, or if an attempt is made to write a read-only stream.

書き込んだ char が戻ってくるが、EOF が返ってきたらエラーである。

== 1.5 プログラムとプロセス ==

 プロセスとプロセスID::
   プログラムの実行中のインスタンスをプロセスと呼ぶ。
   プロセスにはプロセスIDという一意な値が割り当てられる。この値は非負の整数である。